/**
 * This file was automatically generated by nexus-prisma@0.3.7
 * Do not make changes to this file directly
 */

import { core } from 'nexus'
import { GraphQLResolveInfo } from 'graphql'
import * as prisma from '../prisma-client'

declare global {
  interface NexusPrismaGen extends NexusPrismaTypes {}
}

export interface NexusPrismaTypes {
  objectTypes: {
    fields: {
      Query: QueryObject
      User: UserObject
      Joke: JokeObject
      UserConnection: UserConnectionObject
      PageInfo: PageInfoObject
      UserEdge: UserEdgeObject
      AggregateUser: AggregateUserObject
      JokeConnection: JokeConnectionObject
      JokeEdge: JokeEdgeObject
      AggregateJoke: AggregateJokeObject
      Comment: CommentObject
      CommentConnection: CommentConnectionObject
      CommentEdge: CommentEdgeObject
      AggregateComment: AggregateCommentObject
      Vote: VoteObject
      VoteConnection: VoteConnectionObject
      VoteEdge: VoteEdgeObject
      AggregateVote: AggregateVoteObject
      Mutation: MutationObject
      BatchPayload: BatchPayloadObject
      Subscription: SubscriptionObject
      UserSubscriptionPayload: UserSubscriptionPayloadObject
      UserPreviousValues: UserPreviousValuesObject
      JokeSubscriptionPayload: JokeSubscriptionPayloadObject
      JokePreviousValues: JokePreviousValuesObject
      CommentSubscriptionPayload: CommentSubscriptionPayloadObject
      CommentPreviousValues: CommentPreviousValuesObject
      VoteSubscriptionPayload: VoteSubscriptionPayloadObject
      VotePreviousValues: VotePreviousValuesObject
    }
    fieldsDetails: {
      Query: QueryFieldDetails
      User: UserFieldDetails
      Joke: JokeFieldDetails
      UserConnection: UserConnectionFieldDetails
      PageInfo: PageInfoFieldDetails
      UserEdge: UserEdgeFieldDetails
      AggregateUser: AggregateUserFieldDetails
      JokeConnection: JokeConnectionFieldDetails
      JokeEdge: JokeEdgeFieldDetails
      AggregateJoke: AggregateJokeFieldDetails
      Comment: CommentFieldDetails
      CommentConnection: CommentConnectionFieldDetails
      CommentEdge: CommentEdgeFieldDetails
      AggregateComment: AggregateCommentFieldDetails
      Vote: VoteFieldDetails
      VoteConnection: VoteConnectionFieldDetails
      VoteEdge: VoteEdgeFieldDetails
      AggregateVote: AggregateVoteFieldDetails
      Mutation: MutationFieldDetails
      BatchPayload: BatchPayloadFieldDetails
      Subscription: SubscriptionFieldDetails
      UserSubscriptionPayload: UserSubscriptionPayloadFieldDetails
      UserPreviousValues: UserPreviousValuesFieldDetails
      JokeSubscriptionPayload: JokeSubscriptionPayloadFieldDetails
      JokePreviousValues: JokePreviousValuesFieldDetails
      CommentSubscriptionPayload: CommentSubscriptionPayloadFieldDetails
      CommentPreviousValues: CommentPreviousValuesFieldDetails
      VoteSubscriptionPayload: VoteSubscriptionPayloadFieldDetails
      VotePreviousValues: VotePreviousValuesFieldDetails
    }
  }
  inputTypes: {
    fields: {
      UserWhereUniqueInput: UserWhereUniqueInputInputObject
      JokeWhereInput: JokeWhereInputInputObject
      UserWhereInput: UserWhereInputInputObject
      JokeWhereUniqueInput: JokeWhereUniqueInputInputObject
      CommentWhereUniqueInput: CommentWhereUniqueInputInputObject
      CommentWhereInput: CommentWhereInputInputObject
      VoteWhereUniqueInput: VoteWhereUniqueInputInputObject
      VoteWhereInput: VoteWhereInputInputObject
      UserCreateInput: UserCreateInputInputObject
      JokeCreateManyWithoutAuthorInput: JokeCreateManyWithoutAuthorInputInputObject
      JokeCreateWithoutAuthorInput: JokeCreateWithoutAuthorInputInputObject
      UserUpdateInput: UserUpdateInputInputObject
      JokeUpdateManyWithoutAuthorInput: JokeUpdateManyWithoutAuthorInputInputObject
      JokeUpdateWithWhereUniqueWithoutAuthorInput: JokeUpdateWithWhereUniqueWithoutAuthorInputInputObject
      JokeUpdateWithoutAuthorDataInput: JokeUpdateWithoutAuthorDataInputInputObject
      JokeUpsertWithWhereUniqueWithoutAuthorInput: JokeUpsertWithWhereUniqueWithoutAuthorInputInputObject
      JokeScalarWhereInput: JokeScalarWhereInputInputObject
      JokeUpdateManyWithWhereNestedInput: JokeUpdateManyWithWhereNestedInputInputObject
      JokeUpdateManyDataInput: JokeUpdateManyDataInputInputObject
      UserUpdateManyMutationInput: UserUpdateManyMutationInputInputObject
      JokeCreateInput: JokeCreateInputInputObject
      UserCreateOneWithoutJokesInput: UserCreateOneWithoutJokesInputInputObject
      UserCreateWithoutJokesInput: UserCreateWithoutJokesInputInputObject
      JokeUpdateInput: JokeUpdateInputInputObject
      UserUpdateOneWithoutJokesInput: UserUpdateOneWithoutJokesInputInputObject
      UserUpdateWithoutJokesDataInput: UserUpdateWithoutJokesDataInputInputObject
      UserUpsertWithoutJokesInput: UserUpsertWithoutJokesInputInputObject
      JokeUpdateManyMutationInput: JokeUpdateManyMutationInputInputObject
      CommentCreateInput: CommentCreateInputInputObject
      UserCreateOneInput: UserCreateOneInputInputObject
      JokeCreateOneInput: JokeCreateOneInputInputObject
      CommentUpdateInput: CommentUpdateInputInputObject
      UserUpdateOneInput: UserUpdateOneInputInputObject
      UserUpdateDataInput: UserUpdateDataInputInputObject
      UserUpsertNestedInput: UserUpsertNestedInputInputObject
      JokeUpdateOneInput: JokeUpdateOneInputInputObject
      JokeUpdateDataInput: JokeUpdateDataInputInputObject
      JokeUpsertNestedInput: JokeUpsertNestedInputInputObject
      CommentUpdateManyMutationInput: CommentUpdateManyMutationInputInputObject
      VoteCreateInput: VoteCreateInputInputObject
      VoteUpdateInput: VoteUpdateInputInputObject
      VoteUpdateManyMutationInput: VoteUpdateManyMutationInputInputObject
      UserSubscriptionWhereInput: UserSubscriptionWhereInputInputObject
      JokeSubscriptionWhereInput: JokeSubscriptionWhereInputInputObject
      CommentSubscriptionWhereInput: CommentSubscriptionWhereInputInputObject
      VoteSubscriptionWhereInput: VoteSubscriptionWhereInputInputObject
    }
  }
  enumTypes: {
    JokeOrderByInput: JokeOrderByInputValues,
    UserOrderByInput: UserOrderByInputValues,
    CommentOrderByInput: CommentOrderByInputValues,
    VoteOrderByInput: VoteOrderByInputValues,
    MutationType: MutationTypeValues,
  }
}

// Types for Query

type QueryObject =
  | QueryFields
  | { name: 'user', args?: QueryUserArgs[] | false, alias?: string  } 
  | { name: 'users', args?: QueryUsersArgs[] | false, alias?: string  } 
  | { name: 'usersConnection', args?: QueryUsersConnectionArgs[] | false, alias?: string  } 
  | { name: 'joke', args?: QueryJokeArgs[] | false, alias?: string  } 
  | { name: 'jokes', args?: QueryJokesArgs[] | false, alias?: string  } 
  | { name: 'jokesConnection', args?: QueryJokesConnectionArgs[] | false, alias?: string  } 
  | { name: 'comment', args?: QueryCommentArgs[] | false, alias?: string  } 
  | { name: 'comments', args?: QueryCommentsArgs[] | false, alias?: string  } 
  | { name: 'commentsConnection', args?: QueryCommentsConnectionArgs[] | false, alias?: string  } 
  | { name: 'vote', args?: QueryVoteArgs[] | false, alias?: string  } 
  | { name: 'votes', args?: QueryVotesArgs[] | false, alias?: string  } 
  | { name: 'votesConnection', args?: QueryVotesConnectionArgs[] | false, alias?: string  } 

type QueryFields =
  | 'user'
  | 'users'
  | 'usersConnection'
  | 'joke'
  | 'jokes'
  | 'jokesConnection'
  | 'comment'
  | 'comments'
  | 'commentsConnection'
  | 'vote'
  | 'votes'
  | 'votesConnection'


type QueryUserArgs =
  | 'where'
type QueryUsersArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryUsersConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryJokeArgs =
  | 'where'
type QueryJokesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryJokesConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryCommentArgs =
  | 'where'
type QueryCommentsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryCommentsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryVoteArgs =
  | 'where'
type QueryVotesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryVotesConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface QueryFieldDetails {
  user: {
    type: 'User'
    args: Record<QueryUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  users: {
    type: 'User'
    args: Record<QueryUsersArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: UserWhereInput | null, orderBy?: prisma.UserOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User[]> | prisma.User[]
  }
  usersConnection: {
    type: 'UserConnection'
    args: Record<QueryUsersConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: UserWhereInput | null, orderBy?: prisma.UserOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserConnection> | prisma.UserConnection
  }
  joke: {
    type: 'Joke'
    args: Record<QueryJokeArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: JokeWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Joke | null> | prisma.Joke | null
  }
  jokes: {
    type: 'Joke'
    args: Record<QueryJokesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: JokeWhereInput | null, orderBy?: prisma.JokeOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Joke[]> | prisma.Joke[]
  }
  jokesConnection: {
    type: 'JokeConnection'
    args: Record<QueryJokesConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: JokeWhereInput | null, orderBy?: prisma.JokeOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.JokeConnection> | prisma.JokeConnection
  }
  comment: {
    type: 'Comment'
    args: Record<QueryCommentArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: CommentWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment | null> | prisma.Comment | null
  }
  comments: {
    type: 'Comment'
    args: Record<QueryCommentsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: CommentWhereInput | null, orderBy?: prisma.CommentOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment[]> | prisma.Comment[]
  }
  commentsConnection: {
    type: 'CommentConnection'
    args: Record<QueryCommentsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: CommentWhereInput | null, orderBy?: prisma.CommentOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CommentConnection> | prisma.CommentConnection
  }
  vote: {
    type: 'Vote'
    args: Record<QueryVoteArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: VoteWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote | null> | prisma.Vote | null
  }
  votes: {
    type: 'Vote'
    args: Record<QueryVotesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: VoteWhereInput | null, orderBy?: prisma.VoteOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote[]> | prisma.Vote[]
  }
  votesConnection: {
    type: 'VoteConnection'
    args: Record<QueryVotesConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: VoteWhereInput | null, orderBy?: prisma.VoteOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.VoteConnection> | prisma.VoteConnection
  }
}
  

// Types for User

type UserObject =
  | UserFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'email', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'jokes', args?: UserJokesArgs[] | false, alias?: string  } 

type UserFields =
  | 'id'
  | 'email'
  | 'name'
  | 'jokes'


type UserJokesArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface UserFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  email: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  jokes: {
    type: 'Joke'
    args: Record<UserJokesArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"User">,
      args: { where?: JokeWhereInput | null, orderBy?: prisma.JokeOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Joke[]> | prisma.Joke[]
  }
}
  

// Types for Joke

type JokeObject =
  | JokeFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'content', args?: [] | false, alias?: string  } 
  | { name: 'published', args?: [] | false, alias?: string  } 
  | { name: 'author', args?: [] | false, alias?: string  } 

type JokeFields =
  | 'id'
  | 'content'
  | 'published'
  | 'author'



  

export interface JokeFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  content: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  published: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  author: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Joke">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
}
  

// Types for UserConnection

type UserConnectionObject =
  | UserConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type UserConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface UserConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'UserEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserEdge[]> | prisma.UserEdge[]
  }
  aggregate: {
    type: 'AggregateUser'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateUser> | prisma.AggregateUser
  }
}
  

// Types for PageInfo

type PageInfoObject =
  | PageInfoFields
  | { name: 'hasNextPage', args?: [] | false, alias?: string  } 
  | { name: 'hasPreviousPage', args?: [] | false, alias?: string  } 
  | { name: 'startCursor', args?: [] | false, alias?: string  } 
  | { name: 'endCursor', args?: [] | false, alias?: string  } 

type PageInfoFields =
  | 'hasNextPage'
  | 'hasPreviousPage'
  | 'startCursor'
  | 'endCursor'



  

export interface PageInfoFieldDetails {
  hasNextPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  hasPreviousPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  startCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  endCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for UserEdge

type UserEdgeObject =
  | UserEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type UserEdgeFields =
  | 'node'
  | 'cursor'



  

export interface UserEdgeFieldDetails {
  node: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateUser

type AggregateUserObject =
  | AggregateUserFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateUserFields =
  | 'count'



  

export interface AggregateUserFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for JokeConnection

type JokeConnectionObject =
  | JokeConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type JokeConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface JokeConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"JokeConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'JokeEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"JokeConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.JokeEdge[]> | prisma.JokeEdge[]
  }
  aggregate: {
    type: 'AggregateJoke'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"JokeConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateJoke> | prisma.AggregateJoke
  }
}
  

// Types for JokeEdge

type JokeEdgeObject =
  | JokeEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type JokeEdgeFields =
  | 'node'
  | 'cursor'



  

export interface JokeEdgeFieldDetails {
  node: {
    type: 'Joke'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"JokeEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Joke> | prisma.Joke
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateJoke

type AggregateJokeObject =
  | AggregateJokeFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateJokeFields =
  | 'count'



  

export interface AggregateJokeFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Comment

type CommentObject =
  | CommentFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'author', args?: [] | false, alias?: string  } 
  | { name: 'joke', args?: [] | false, alias?: string  } 
  | { name: 'content', args?: [] | false, alias?: string  } 

type CommentFields =
  | 'id'
  | 'author'
  | 'joke'
  | 'content'



  

export interface CommentFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  author: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Comment">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  joke: {
    type: 'Joke'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Comment">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Joke | null> | prisma.Joke | null
  }
  content: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for CommentConnection

type CommentConnectionObject =
  | CommentConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type CommentConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface CommentConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CommentConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'CommentEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"CommentConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CommentEdge[]> | prisma.CommentEdge[]
  }
  aggregate: {
    type: 'AggregateComment'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CommentConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateComment> | prisma.AggregateComment
  }
}
  

// Types for CommentEdge

type CommentEdgeObject =
  | CommentEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type CommentEdgeFields =
  | 'node'
  | 'cursor'



  

export interface CommentEdgeFieldDetails {
  node: {
    type: 'Comment'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CommentEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment> | prisma.Comment
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateComment

type AggregateCommentObject =
  | AggregateCommentFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateCommentFields =
  | 'count'



  

export interface AggregateCommentFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Vote

type VoteObject =
  | VoteFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'author', args?: [] | false, alias?: string  } 
  | { name: 'joke', args?: [] | false, alias?: string  } 
  | { name: 'value', args?: [] | false, alias?: string  } 

type VoteFields =
  | 'id'
  | 'author'
  | 'joke'
  | 'value'



  

export interface VoteFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  author: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Vote">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  joke: {
    type: 'Joke'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Vote">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Joke | null> | prisma.Joke | null
  }
  value: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for VoteConnection

type VoteConnectionObject =
  | VoteConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type VoteConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface VoteConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"VoteConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'VoteEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"VoteConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.VoteEdge[]> | prisma.VoteEdge[]
  }
  aggregate: {
    type: 'AggregateVote'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"VoteConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateVote> | prisma.AggregateVote
  }
}
  

// Types for VoteEdge

type VoteEdgeObject =
  | VoteEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type VoteEdgeFields =
  | 'node'
  | 'cursor'



  

export interface VoteEdgeFieldDetails {
  node: {
    type: 'Vote'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"VoteEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote> | prisma.Vote
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateVote

type AggregateVoteObject =
  | AggregateVoteFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateVoteFields =
  | 'count'



  

export interface AggregateVoteFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Mutation

type MutationObject =
  | MutationFields
  | { name: 'createUser', args?: MutationCreateUserArgs[] | false, alias?: string  } 
  | { name: 'updateUser', args?: MutationUpdateUserArgs[] | false, alias?: string  } 
  | { name: 'updateManyUsers', args?: MutationUpdateManyUsersArgs[] | false, alias?: string  } 
  | { name: 'upsertUser', args?: MutationUpsertUserArgs[] | false, alias?: string  } 
  | { name: 'deleteUser', args?: MutationDeleteUserArgs[] | false, alias?: string  } 
  | { name: 'deleteManyUsers', args?: MutationDeleteManyUsersArgs[] | false, alias?: string  } 
  | { name: 'createJoke', args?: MutationCreateJokeArgs[] | false, alias?: string  } 
  | { name: 'updateJoke', args?: MutationUpdateJokeArgs[] | false, alias?: string  } 
  | { name: 'updateManyJokes', args?: MutationUpdateManyJokesArgs[] | false, alias?: string  } 
  | { name: 'upsertJoke', args?: MutationUpsertJokeArgs[] | false, alias?: string  } 
  | { name: 'deleteJoke', args?: MutationDeleteJokeArgs[] | false, alias?: string  } 
  | { name: 'deleteManyJokes', args?: MutationDeleteManyJokesArgs[] | false, alias?: string  } 
  | { name: 'createComment', args?: MutationCreateCommentArgs[] | false, alias?: string  } 
  | { name: 'updateComment', args?: MutationUpdateCommentArgs[] | false, alias?: string  } 
  | { name: 'updateManyComments', args?: MutationUpdateManyCommentsArgs[] | false, alias?: string  } 
  | { name: 'upsertComment', args?: MutationUpsertCommentArgs[] | false, alias?: string  } 
  | { name: 'deleteComment', args?: MutationDeleteCommentArgs[] | false, alias?: string  } 
  | { name: 'deleteManyComments', args?: MutationDeleteManyCommentsArgs[] | false, alias?: string  } 
  | { name: 'createVote', args?: MutationCreateVoteArgs[] | false, alias?: string  } 
  | { name: 'updateVote', args?: MutationUpdateVoteArgs[] | false, alias?: string  } 
  | { name: 'updateManyVotes', args?: MutationUpdateManyVotesArgs[] | false, alias?: string  } 
  | { name: 'upsertVote', args?: MutationUpsertVoteArgs[] | false, alias?: string  } 
  | { name: 'deleteVote', args?: MutationDeleteVoteArgs[] | false, alias?: string  } 
  | { name: 'deleteManyVotes', args?: MutationDeleteManyVotesArgs[] | false, alias?: string  } 

type MutationFields =
  | 'createUser'
  | 'updateUser'
  | 'updateManyUsers'
  | 'upsertUser'
  | 'deleteUser'
  | 'deleteManyUsers'
  | 'createJoke'
  | 'updateJoke'
  | 'updateManyJokes'
  | 'upsertJoke'
  | 'deleteJoke'
  | 'deleteManyJokes'
  | 'createComment'
  | 'updateComment'
  | 'updateManyComments'
  | 'upsertComment'
  | 'deleteComment'
  | 'deleteManyComments'
  | 'createVote'
  | 'updateVote'
  | 'updateManyVotes'
  | 'upsertVote'
  | 'deleteVote'
  | 'deleteManyVotes'


type MutationCreateUserArgs =
  | 'data'
type MutationUpdateUserArgs =
  | 'data'
  | 'where'
type MutationUpdateManyUsersArgs =
  | 'data'
  | 'where'
type MutationUpsertUserArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteUserArgs =
  | 'where'
type MutationDeleteManyUsersArgs =
  | 'where'
type MutationCreateJokeArgs =
  | 'data'
type MutationUpdateJokeArgs =
  | 'data'
  | 'where'
type MutationUpdateManyJokesArgs =
  | 'data'
  | 'where'
type MutationUpsertJokeArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteJokeArgs =
  | 'where'
type MutationDeleteManyJokesArgs =
  | 'where'
type MutationCreateCommentArgs =
  | 'data'
type MutationUpdateCommentArgs =
  | 'data'
  | 'where'
type MutationUpdateManyCommentsArgs =
  | 'data'
  | 'where'
type MutationUpsertCommentArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteCommentArgs =
  | 'where'
type MutationDeleteManyCommentsArgs =
  | 'where'
type MutationCreateVoteArgs =
  | 'data'
type MutationUpdateVoteArgs =
  | 'data'
  | 'where'
type MutationUpdateManyVotesArgs =
  | 'data'
  | 'where'
type MutationUpsertVoteArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteVoteArgs =
  | 'where'
type MutationDeleteManyVotesArgs =
  | 'where'
  

export interface MutationFieldDetails {
  createUser: {
    type: 'User'
    args: Record<MutationCreateUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  updateUser: {
    type: 'User'
    args: Record<MutationUpdateUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserUpdateInput, where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  updateManyUsers: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyUsersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserUpdateManyMutationInput, where?: UserWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertUser: {
    type: 'User'
    args: Record<MutationUpsertUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: UserWhereUniqueInput, create: UserCreateInput, update: UserUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  deleteUser: {
    type: 'User'
    args: Record<MutationDeleteUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  deleteManyUsers: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyUsersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: UserWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createJoke: {
    type: 'Joke'
    args: Record<MutationCreateJokeArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: JokeCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Joke> | prisma.Joke
  }
  updateJoke: {
    type: 'Joke'
    args: Record<MutationUpdateJokeArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: JokeUpdateInput, where: JokeWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Joke | null> | prisma.Joke | null
  }
  updateManyJokes: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyJokesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: JokeUpdateManyMutationInput, where?: JokeWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertJoke: {
    type: 'Joke'
    args: Record<MutationUpsertJokeArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: JokeWhereUniqueInput, create: JokeCreateInput, update: JokeUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Joke> | prisma.Joke
  }
  deleteJoke: {
    type: 'Joke'
    args: Record<MutationDeleteJokeArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: JokeWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Joke | null> | prisma.Joke | null
  }
  deleteManyJokes: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyJokesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: JokeWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createComment: {
    type: 'Comment'
    args: Record<MutationCreateCommentArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CommentCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment> | prisma.Comment
  }
  updateComment: {
    type: 'Comment'
    args: Record<MutationUpdateCommentArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CommentUpdateInput, where: CommentWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment | null> | prisma.Comment | null
  }
  updateManyComments: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyCommentsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CommentUpdateManyMutationInput, where?: CommentWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertComment: {
    type: 'Comment'
    args: Record<MutationUpsertCommentArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: CommentWhereUniqueInput, create: CommentCreateInput, update: CommentUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment> | prisma.Comment
  }
  deleteComment: {
    type: 'Comment'
    args: Record<MutationDeleteCommentArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: CommentWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment | null> | prisma.Comment | null
  }
  deleteManyComments: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyCommentsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: CommentWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createVote: {
    type: 'Vote'
    args: Record<MutationCreateVoteArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: VoteCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote> | prisma.Vote
  }
  updateVote: {
    type: 'Vote'
    args: Record<MutationUpdateVoteArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: VoteUpdateInput, where: VoteWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote | null> | prisma.Vote | null
  }
  updateManyVotes: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyVotesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: VoteUpdateManyMutationInput, where?: VoteWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertVote: {
    type: 'Vote'
    args: Record<MutationUpsertVoteArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: VoteWhereUniqueInput, create: VoteCreateInput, update: VoteUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote> | prisma.Vote
  }
  deleteVote: {
    type: 'Vote'
    args: Record<MutationDeleteVoteArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: VoteWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote | null> | prisma.Vote | null
  }
  deleteManyVotes: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyVotesArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: VoteWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
}
  

// Types for BatchPayload

type BatchPayloadObject =
  | BatchPayloadFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type BatchPayloadFields =
  | 'count'



  

export interface BatchPayloadFieldDetails {
  count: {
    type: 'Long'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Subscription

type SubscriptionObject =
  | SubscriptionFields
  | { name: 'user', args?: SubscriptionUserArgs[] | false, alias?: string  } 
  | { name: 'joke', args?: SubscriptionJokeArgs[] | false, alias?: string  } 
  | { name: 'comment', args?: SubscriptionCommentArgs[] | false, alias?: string  } 
  | { name: 'vote', args?: SubscriptionVoteArgs[] | false, alias?: string  } 

type SubscriptionFields =
  | 'user'
  | 'joke'
  | 'comment'
  | 'vote'


type SubscriptionUserArgs =
  | 'where'
type SubscriptionJokeArgs =
  | 'where'
type SubscriptionCommentArgs =
  | 'where'
type SubscriptionVoteArgs =
  | 'where'
  

export interface SubscriptionFieldDetails {
  user: {
    type: 'UserSubscriptionPayload'
    args: Record<SubscriptionUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: UserSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserSubscriptionPayload | null> | prisma.UserSubscriptionPayload | null
  }
  joke: {
    type: 'JokeSubscriptionPayload'
    args: Record<SubscriptionJokeArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: JokeSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.JokeSubscriptionPayload | null> | prisma.JokeSubscriptionPayload | null
  }
  comment: {
    type: 'CommentSubscriptionPayload'
    args: Record<SubscriptionCommentArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: CommentSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CommentSubscriptionPayload | null> | prisma.CommentSubscriptionPayload | null
  }
  vote: {
    type: 'VoteSubscriptionPayload'
    args: Record<SubscriptionVoteArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: VoteSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.VoteSubscriptionPayload | null> | prisma.VoteSubscriptionPayload | null
  }
}
  

// Types for UserSubscriptionPayload

type UserSubscriptionPayloadObject =
  | UserSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type UserSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface UserSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'UserPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserPreviousValues | null> | prisma.UserPreviousValues | null
  }
}
  

// Types for UserPreviousValues

type UserPreviousValuesObject =
  | UserPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'email', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 

type UserPreviousValuesFields =
  | 'id'
  | 'email'
  | 'name'



  

export interface UserPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  email: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for JokeSubscriptionPayload

type JokeSubscriptionPayloadObject =
  | JokeSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type JokeSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface JokeSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"JokeSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Joke'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"JokeSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Joke | null> | prisma.Joke | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'JokePreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"JokeSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.JokePreviousValues | null> | prisma.JokePreviousValues | null
  }
}
  

// Types for JokePreviousValues

type JokePreviousValuesObject =
  | JokePreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'content', args?: [] | false, alias?: string  } 
  | { name: 'published', args?: [] | false, alias?: string  } 

type JokePreviousValuesFields =
  | 'id'
  | 'content'
  | 'published'



  

export interface JokePreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  content: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  published: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for CommentSubscriptionPayload

type CommentSubscriptionPayloadObject =
  | CommentSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type CommentSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface CommentSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CommentSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Comment'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"CommentSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment | null> | prisma.Comment | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'CommentPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"CommentSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CommentPreviousValues | null> | prisma.CommentPreviousValues | null
  }
}
  

// Types for CommentPreviousValues

type CommentPreviousValuesObject =
  | CommentPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'content', args?: [] | false, alias?: string  } 

type CommentPreviousValuesFields =
  | 'id'
  | 'content'



  

export interface CommentPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  content: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for VoteSubscriptionPayload

type VoteSubscriptionPayloadObject =
  | VoteSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type VoteSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface VoteSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"VoteSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Vote'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"VoteSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Vote | null> | prisma.Vote | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'VotePreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"VoteSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.VotePreviousValues | null> | prisma.VotePreviousValues | null
  }
}
  

// Types for VotePreviousValues

type VotePreviousValuesObject =
  | VotePreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'value', args?: [] | false, alias?: string  } 

type VotePreviousValuesFields =
  | 'id'
  | 'value'



  

export interface VotePreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  value: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  


export interface UserWhereUniqueInput {
  id?: string | null
  email?: string | null
}
export type UserWhereUniqueInputInputObject =
  | Extract<keyof UserWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'email', alias?: string  } 
  
export interface JokeWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  content?: string | null
  content_not?: string | null
  content_in?: string[]
  content_not_in?: string[]
  content_lt?: string | null
  content_lte?: string | null
  content_gt?: string | null
  content_gte?: string | null
  content_contains?: string | null
  content_not_contains?: string | null
  content_starts_with?: string | null
  content_not_starts_with?: string | null
  content_ends_with?: string | null
  content_not_ends_with?: string | null
  published?: boolean | null
  published_not?: boolean | null
  author?: UserWhereInput | null
  AND?: JokeWhereInput[]
  OR?: JokeWhereInput[]
  NOT?: JokeWhereInput[]
}
export type JokeWhereInputInputObject =
  | Extract<keyof JokeWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'content', alias?: string  } 
  | { name: 'content_not', alias?: string  } 
  | { name: 'content_in', alias?: string  } 
  | { name: 'content_not_in', alias?: string  } 
  | { name: 'content_lt', alias?: string  } 
  | { name: 'content_lte', alias?: string  } 
  | { name: 'content_gt', alias?: string  } 
  | { name: 'content_gte', alias?: string  } 
  | { name: 'content_contains', alias?: string  } 
  | { name: 'content_not_contains', alias?: string  } 
  | { name: 'content_starts_with', alias?: string  } 
  | { name: 'content_not_starts_with', alias?: string  } 
  | { name: 'content_ends_with', alias?: string  } 
  | { name: 'content_not_ends_with', alias?: string  } 
  | { name: 'published', alias?: string  } 
  | { name: 'published_not', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface UserWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  email?: string | null
  email_not?: string | null
  email_in?: string[]
  email_not_in?: string[]
  email_lt?: string | null
  email_lte?: string | null
  email_gt?: string | null
  email_gte?: string | null
  email_contains?: string | null
  email_not_contains?: string | null
  email_starts_with?: string | null
  email_not_starts_with?: string | null
  email_ends_with?: string | null
  email_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  jokes_every?: JokeWhereInput | null
  jokes_some?: JokeWhereInput | null
  jokes_none?: JokeWhereInput | null
  AND?: UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput[]
}
export type UserWhereInputInputObject =
  | Extract<keyof UserWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'email_not', alias?: string  } 
  | { name: 'email_in', alias?: string  } 
  | { name: 'email_not_in', alias?: string  } 
  | { name: 'email_lt', alias?: string  } 
  | { name: 'email_lte', alias?: string  } 
  | { name: 'email_gt', alias?: string  } 
  | { name: 'email_gte', alias?: string  } 
  | { name: 'email_contains', alias?: string  } 
  | { name: 'email_not_contains', alias?: string  } 
  | { name: 'email_starts_with', alias?: string  } 
  | { name: 'email_not_starts_with', alias?: string  } 
  | { name: 'email_ends_with', alias?: string  } 
  | { name: 'email_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'jokes_every', alias?: string  } 
  | { name: 'jokes_some', alias?: string  } 
  | { name: 'jokes_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface JokeWhereUniqueInput {
  id?: string | null
}
export type JokeWhereUniqueInputInputObject =
  | Extract<keyof JokeWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface CommentWhereUniqueInput {
  id?: string | null
}
export type CommentWhereUniqueInputInputObject =
  | Extract<keyof CommentWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface CommentWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  author?: UserWhereInput | null
  joke?: JokeWhereInput | null
  content?: string | null
  content_not?: string | null
  content_in?: string[]
  content_not_in?: string[]
  content_lt?: string | null
  content_lte?: string | null
  content_gt?: string | null
  content_gte?: string | null
  content_contains?: string | null
  content_not_contains?: string | null
  content_starts_with?: string | null
  content_not_starts_with?: string | null
  content_ends_with?: string | null
  content_not_ends_with?: string | null
  AND?: CommentWhereInput[]
  OR?: CommentWhereInput[]
  NOT?: CommentWhereInput[]
}
export type CommentWhereInputInputObject =
  | Extract<keyof CommentWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'joke', alias?: string  } 
  | { name: 'content', alias?: string  } 
  | { name: 'content_not', alias?: string  } 
  | { name: 'content_in', alias?: string  } 
  | { name: 'content_not_in', alias?: string  } 
  | { name: 'content_lt', alias?: string  } 
  | { name: 'content_lte', alias?: string  } 
  | { name: 'content_gt', alias?: string  } 
  | { name: 'content_gte', alias?: string  } 
  | { name: 'content_contains', alias?: string  } 
  | { name: 'content_not_contains', alias?: string  } 
  | { name: 'content_starts_with', alias?: string  } 
  | { name: 'content_not_starts_with', alias?: string  } 
  | { name: 'content_ends_with', alias?: string  } 
  | { name: 'content_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface VoteWhereUniqueInput {
  id?: string | null
}
export type VoteWhereUniqueInputInputObject =
  | Extract<keyof VoteWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  
export interface VoteWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  author?: UserWhereInput | null
  joke?: JokeWhereInput | null
  value?: number | null
  value_not?: number | null
  value_in?: number[]
  value_not_in?: number[]
  value_lt?: number | null
  value_lte?: number | null
  value_gt?: number | null
  value_gte?: number | null
  AND?: VoteWhereInput[]
  OR?: VoteWhereInput[]
  NOT?: VoteWhereInput[]
}
export type VoteWhereInputInputObject =
  | Extract<keyof VoteWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'joke', alias?: string  } 
  | { name: 'value', alias?: string  } 
  | { name: 'value_not', alias?: string  } 
  | { name: 'value_in', alias?: string  } 
  | { name: 'value_not_in', alias?: string  } 
  | { name: 'value_lt', alias?: string  } 
  | { name: 'value_lte', alias?: string  } 
  | { name: 'value_gt', alias?: string  } 
  | { name: 'value_gte', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface UserCreateInput {
  id?: string | null
  email?: string | null
  name?: string
  jokes?: JokeCreateManyWithoutAuthorInput | null
}
export type UserCreateInputInputObject =
  | Extract<keyof UserCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'jokes', alias?: string  } 
  
export interface JokeCreateManyWithoutAuthorInput {
  create?: JokeCreateWithoutAuthorInput[]
  connect?: JokeWhereUniqueInput[]
}
export type JokeCreateManyWithoutAuthorInputInputObject =
  | Extract<keyof JokeCreateManyWithoutAuthorInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface JokeCreateWithoutAuthorInput {
  id?: string | null
  content?: string
  published?: boolean | null
}
export type JokeCreateWithoutAuthorInputInputObject =
  | Extract<keyof JokeCreateWithoutAuthorInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'content', alias?: string  } 
  | { name: 'published', alias?: string  } 
  
export interface UserUpdateInput {
  email?: string | null
  name?: string | null
  jokes?: JokeUpdateManyWithoutAuthorInput | null
}
export type UserUpdateInputInputObject =
  | Extract<keyof UserUpdateInput, string>
  | { name: 'email', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'jokes', alias?: string  } 
  
export interface JokeUpdateManyWithoutAuthorInput {
  create?: JokeCreateWithoutAuthorInput[]
  delete?: JokeWhereUniqueInput[]
  connect?: JokeWhereUniqueInput[]
  set?: JokeWhereUniqueInput[]
  disconnect?: JokeWhereUniqueInput[]
  update?: JokeUpdateWithWhereUniqueWithoutAuthorInput[]
  upsert?: JokeUpsertWithWhereUniqueWithoutAuthorInput[]
  deleteMany?: JokeScalarWhereInput[]
  updateMany?: JokeUpdateManyWithWhereNestedInput[]
}
export type JokeUpdateManyWithoutAuthorInputInputObject =
  | Extract<keyof JokeUpdateManyWithoutAuthorInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface JokeUpdateWithWhereUniqueWithoutAuthorInput {
  where?: JokeWhereUniqueInput
  data?: JokeUpdateWithoutAuthorDataInput
}
export type JokeUpdateWithWhereUniqueWithoutAuthorInputInputObject =
  | Extract<keyof JokeUpdateWithWhereUniqueWithoutAuthorInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface JokeUpdateWithoutAuthorDataInput {
  content?: string | null
  published?: boolean | null
}
export type JokeUpdateWithoutAuthorDataInputInputObject =
  | Extract<keyof JokeUpdateWithoutAuthorDataInput, string>
  | { name: 'content', alias?: string  } 
  | { name: 'published', alias?: string  } 
  
export interface JokeUpsertWithWhereUniqueWithoutAuthorInput {
  where?: JokeWhereUniqueInput
  update?: JokeUpdateWithoutAuthorDataInput
  create?: JokeCreateWithoutAuthorInput
}
export type JokeUpsertWithWhereUniqueWithoutAuthorInputInputObject =
  | Extract<keyof JokeUpsertWithWhereUniqueWithoutAuthorInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface JokeScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  content?: string | null
  content_not?: string | null
  content_in?: string[]
  content_not_in?: string[]
  content_lt?: string | null
  content_lte?: string | null
  content_gt?: string | null
  content_gte?: string | null
  content_contains?: string | null
  content_not_contains?: string | null
  content_starts_with?: string | null
  content_not_starts_with?: string | null
  content_ends_with?: string | null
  content_not_ends_with?: string | null
  published?: boolean | null
  published_not?: boolean | null
  AND?: JokeScalarWhereInput[]
  OR?: JokeScalarWhereInput[]
  NOT?: JokeScalarWhereInput[]
}
export type JokeScalarWhereInputInputObject =
  | Extract<keyof JokeScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'content', alias?: string  } 
  | { name: 'content_not', alias?: string  } 
  | { name: 'content_in', alias?: string  } 
  | { name: 'content_not_in', alias?: string  } 
  | { name: 'content_lt', alias?: string  } 
  | { name: 'content_lte', alias?: string  } 
  | { name: 'content_gt', alias?: string  } 
  | { name: 'content_gte', alias?: string  } 
  | { name: 'content_contains', alias?: string  } 
  | { name: 'content_not_contains', alias?: string  } 
  | { name: 'content_starts_with', alias?: string  } 
  | { name: 'content_not_starts_with', alias?: string  } 
  | { name: 'content_ends_with', alias?: string  } 
  | { name: 'content_not_ends_with', alias?: string  } 
  | { name: 'published', alias?: string  } 
  | { name: 'published_not', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface JokeUpdateManyWithWhereNestedInput {
  where?: JokeScalarWhereInput
  data?: JokeUpdateManyDataInput
}
export type JokeUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof JokeUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface JokeUpdateManyDataInput {
  content?: string | null
  published?: boolean | null
}
export type JokeUpdateManyDataInputInputObject =
  | Extract<keyof JokeUpdateManyDataInput, string>
  | { name: 'content', alias?: string  } 
  | { name: 'published', alias?: string  } 
  
export interface UserUpdateManyMutationInput {
  email?: string | null
  name?: string | null
}
export type UserUpdateManyMutationInputInputObject =
  | Extract<keyof UserUpdateManyMutationInput, string>
  | { name: 'email', alias?: string  } 
  | { name: 'name', alias?: string  } 
  
export interface JokeCreateInput {
  id?: string | null
  content?: string
  published?: boolean | null
  author?: UserCreateOneWithoutJokesInput | null
}
export type JokeCreateInputInputObject =
  | Extract<keyof JokeCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'content', alias?: string  } 
  | { name: 'published', alias?: string  } 
  | { name: 'author', alias?: string  } 
  
export interface UserCreateOneWithoutJokesInput {
  create?: UserCreateWithoutJokesInput | null
  connect?: UserWhereUniqueInput | null
}
export type UserCreateOneWithoutJokesInputInputObject =
  | Extract<keyof UserCreateOneWithoutJokesInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserCreateWithoutJokesInput {
  id?: string | null
  email?: string | null
  name?: string
}
export type UserCreateWithoutJokesInputInputObject =
  | Extract<keyof UserCreateWithoutJokesInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'name', alias?: string  } 
  
export interface JokeUpdateInput {
  content?: string | null
  published?: boolean | null
  author?: UserUpdateOneWithoutJokesInput | null
}
export type JokeUpdateInputInputObject =
  | Extract<keyof JokeUpdateInput, string>
  | { name: 'content', alias?: string  } 
  | { name: 'published', alias?: string  } 
  | { name: 'author', alias?: string  } 
  
export interface UserUpdateOneWithoutJokesInput {
  create?: UserCreateWithoutJokesInput | null
  update?: UserUpdateWithoutJokesDataInput | null
  upsert?: UserUpsertWithoutJokesInput | null
  delete?: boolean | null
  disconnect?: boolean | null
  connect?: UserWhereUniqueInput | null
}
export type UserUpdateOneWithoutJokesInputInputObject =
  | Extract<keyof UserUpdateOneWithoutJokesInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserUpdateWithoutJokesDataInput {
  email?: string | null
  name?: string | null
}
export type UserUpdateWithoutJokesDataInputInputObject =
  | Extract<keyof UserUpdateWithoutJokesDataInput, string>
  | { name: 'email', alias?: string  } 
  | { name: 'name', alias?: string  } 
  
export interface UserUpsertWithoutJokesInput {
  update?: UserUpdateWithoutJokesDataInput
  create?: UserCreateWithoutJokesInput
}
export type UserUpsertWithoutJokesInputInputObject =
  | Extract<keyof UserUpsertWithoutJokesInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface JokeUpdateManyMutationInput {
  content?: string | null
  published?: boolean | null
}
export type JokeUpdateManyMutationInputInputObject =
  | Extract<keyof JokeUpdateManyMutationInput, string>
  | { name: 'content', alias?: string  } 
  | { name: 'published', alias?: string  } 
  
export interface CommentCreateInput {
  id?: string | null
  author?: UserCreateOneInput | null
  joke?: JokeCreateOneInput | null
  content?: string
}
export type CommentCreateInputInputObject =
  | Extract<keyof CommentCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'joke', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface UserCreateOneInput {
  create?: UserCreateInput | null
  connect?: UserWhereUniqueInput | null
}
export type UserCreateOneInputInputObject =
  | Extract<keyof UserCreateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface JokeCreateOneInput {
  create?: JokeCreateInput | null
  connect?: JokeWhereUniqueInput | null
}
export type JokeCreateOneInputInputObject =
  | Extract<keyof JokeCreateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface CommentUpdateInput {
  author?: UserUpdateOneInput | null
  joke?: JokeUpdateOneInput | null
  content?: string | null
}
export type CommentUpdateInputInputObject =
  | Extract<keyof CommentUpdateInput, string>
  | { name: 'author', alias?: string  } 
  | { name: 'joke', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface UserUpdateOneInput {
  create?: UserCreateInput | null
  update?: UserUpdateDataInput | null
  upsert?: UserUpsertNestedInput | null
  delete?: boolean | null
  disconnect?: boolean | null
  connect?: UserWhereUniqueInput | null
}
export type UserUpdateOneInputInputObject =
  | Extract<keyof UserUpdateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserUpdateDataInput {
  email?: string | null
  name?: string | null
  jokes?: JokeUpdateManyWithoutAuthorInput | null
}
export type UserUpdateDataInputInputObject =
  | Extract<keyof UserUpdateDataInput, string>
  | { name: 'email', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'jokes', alias?: string  } 
  
export interface UserUpsertNestedInput {
  update?: UserUpdateDataInput
  create?: UserCreateInput
}
export type UserUpsertNestedInputInputObject =
  | Extract<keyof UserUpsertNestedInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface JokeUpdateOneInput {
  create?: JokeCreateInput | null
  update?: JokeUpdateDataInput | null
  upsert?: JokeUpsertNestedInput | null
  delete?: boolean | null
  disconnect?: boolean | null
  connect?: JokeWhereUniqueInput | null
}
export type JokeUpdateOneInputInputObject =
  | Extract<keyof JokeUpdateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface JokeUpdateDataInput {
  content?: string | null
  published?: boolean | null
  author?: UserUpdateOneWithoutJokesInput | null
}
export type JokeUpdateDataInputInputObject =
  | Extract<keyof JokeUpdateDataInput, string>
  | { name: 'content', alias?: string  } 
  | { name: 'published', alias?: string  } 
  | { name: 'author', alias?: string  } 
  
export interface JokeUpsertNestedInput {
  update?: JokeUpdateDataInput
  create?: JokeCreateInput
}
export type JokeUpsertNestedInputInputObject =
  | Extract<keyof JokeUpsertNestedInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface CommentUpdateManyMutationInput {
  content?: string | null
}
export type CommentUpdateManyMutationInputInputObject =
  | Extract<keyof CommentUpdateManyMutationInput, string>
  | { name: 'content', alias?: string  } 
  
export interface VoteCreateInput {
  id?: string | null
  author?: UserCreateOneInput | null
  joke?: JokeCreateOneInput | null
  value?: number
}
export type VoteCreateInputInputObject =
  | Extract<keyof VoteCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'joke', alias?: string  } 
  | { name: 'value', alias?: string  } 
  
export interface VoteUpdateInput {
  author?: UserUpdateOneInput | null
  joke?: JokeUpdateOneInput | null
  value?: number | null
}
export type VoteUpdateInputInputObject =
  | Extract<keyof VoteUpdateInput, string>
  | { name: 'author', alias?: string  } 
  | { name: 'joke', alias?: string  } 
  | { name: 'value', alias?: string  } 
  
export interface VoteUpdateManyMutationInput {
  value?: number | null
}
export type VoteUpdateManyMutationInputInputObject =
  | Extract<keyof VoteUpdateManyMutationInput, string>
  | { name: 'value', alias?: string  } 
  
export interface UserSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: UserWhereInput | null
  AND?: UserSubscriptionWhereInput[]
  OR?: UserSubscriptionWhereInput[]
  NOT?: UserSubscriptionWhereInput[]
}
export type UserSubscriptionWhereInputInputObject =
  | Extract<keyof UserSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface JokeSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: JokeWhereInput | null
  AND?: JokeSubscriptionWhereInput[]
  OR?: JokeSubscriptionWhereInput[]
  NOT?: JokeSubscriptionWhereInput[]
}
export type JokeSubscriptionWhereInputInputObject =
  | Extract<keyof JokeSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface CommentSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: CommentWhereInput | null
  AND?: CommentSubscriptionWhereInput[]
  OR?: CommentSubscriptionWhereInput[]
  NOT?: CommentSubscriptionWhereInput[]
}
export type CommentSubscriptionWhereInputInputObject =
  | Extract<keyof CommentSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface VoteSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: VoteWhereInput | null
  AND?: VoteSubscriptionWhereInput[]
  OR?: VoteSubscriptionWhereInput[]
  NOT?: VoteSubscriptionWhereInput[]
}
export type VoteSubscriptionWhereInputInputObject =
  | Extract<keyof VoteSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  

export type JokeOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'content_ASC'
  | 'content_DESC'
  | 'published_ASC'
  | 'published_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type UserOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'email_ASC'
  | 'email_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type CommentOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'content_ASC'
  | 'content_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type VoteOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'value_ASC'
  | 'value_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type MutationTypeValues =
  | 'CREATED'
  | 'UPDATED'
  | 'DELETED'
  
  